Puli at a Glance
================

Why Puli?

Puli_ is a PHP library that manages files, directories and other resources in
a repository - much like a virtual file system. *Resources* can be anything,
but usually we use the term for machine-processed files that are *not* PHP, such
as CSS, JavaScript, XLIFF, YAML, XML or HTML files.

Many people use Composer_ to distribute their packages. These packages contain
both PHP files and resources that are used by the application. Loading PHP files
is easy, thanks to PSR-4_ and Composer's generated autoloader. Loading resources,
however, requires using absolute file paths with plenty of ``..`` segments or
inventing some sort of naming convention, which varies from project to project:

.. code-block:: jinja

    {% include 'AcmeBlogBundle::footer.html.twig' %}

Enter Puli.

Repositories
------------

At its core, Puli provides a simple repository, much like a file system. You can
"mount" files or directories to paths in the repository:

.. code-block:: php

    use Puli\Repository\ResourceRepository;

    $repo = new ResourceRepository();
    $repo->add('/css', '/path/to/project/css');

Here, the local path ``/path/to/project/css`` is mapped to the *Puli path*
``/css``. The file ``style.css`` can now be loaded with its Puli path
``/css/style.css``:

.. code-block:: php

    echo $repo->get('/css/style.css')->getContents();

Composer Integration
--------------------

Usually, however, you don't want to configure the repository by hand. Puli's
`Composer plugin`_ does it all for you. Packages export their resources through
the "resources" key in their ``composer.json`` file:

.. code-block:: json

    {
        "name": "acme/blog",
        "extra": {
            "puli": {
                "resources": {
                    "/acme/blog": "resources"
                }
            }
        }
    }

This package maps its ``resources/`` directory to the Puli path ``/acme/blog``,
which matches the name of the package.

When you install the "acme/blog" package in your application, the plugin
generates a repository for you. This repository contains all the resources that
this package - and all other packages - exports:

.. code-block:: php

    $repo = require_once 'vendor/resource-repository.php';

    echo $repo->get('/acme/blog/css/style.css')->getContents();

Tool Integration
----------------

Puli provides integration layers for PHP libraries. For example, with the
`Twig extension`_ you can refer to other templates via Puli paths:

.. code-block:: jinja

    {% include '/acme/blog/views/footer.html.twig' %}

The `Symfony bridge`_ permits the use of Puli paths in configuration files:

.. code-block:: yaml

    # routing.yml
    _acme_blog:
        resource: /acme/blog/config/routing.yml

With Puli, referring to resources in Composer packages becomes straight-forward.

Resource Overriding
-------------------

Consider that you want to change the contents of
``/acme/blog/views/footer.html.twig`` without touching the original package.
You can copy the file to your project and override it in ``composer.json``:

.. code-block:: json

    {
        "require": {
            "acme/blog": "*"
        },
        "extra": {
            "puli": {
                "resources": {
                    "/acme/blog/views/footer.html.twig": "resources/views/footer.html.twig"
                },
                "override": "acme/blog"
            }
        }
    }

The file ``resources/views/footer.html.twg`` will now be used wherever the
file from the "acme/blog" package is referenced.

Stream Wrappers
---------------

Did you know PHP's `stream wrapper`_ feature? With Puli's stream wrapper, you
can use Puli repositories like ordinary files:

.. code-block:: php

    use Puli\StreamWrapper\ResourceStreamWrapper;
    use Puli\Uri\UriRepository;

    $repo = require 'vendor/resource-repository.php';

    $uriRepo = new UriRepository();
    $uriRepo->register('composer', $repo);

    ResourceStreamWrapper::register($uriRepo);

In this example, the repository generated by Composer is registered for the
"composer://" scheme. The :class:`Puli\\StreamWrapper\\ResourceStreamWrapper`
class registers the schemes with PHP. Now you can access Puli resources like
normal files, as long as you prefix them with "composer://":

.. code-block:: php

    echo file_get_contents('composer:///acme/blog/css/style.css');

Flexibility
-----------

We kept saying "resource" instead of "file" or "directory" because resources
are really independent of the file system. For example, you can implement
custom repositories that load resources from a content management system.
With the :class:`Puli\\Uri\\UriRepository` from the previous example, you can
use both the repository generated by Composer and your own implementation side
by side:

.. code-block:: php

    use My\CmsRepository;
    use Puli\Uri\UriRepository;

    $repo = require 'vendor/resource-repository.php';

    $uriRepo = new UriRepository();
    $uriRepo->register('composer', $repo);
    $uriRepo->register('cms', new CmsRepository());
    $uriRepo->setDefaultScheme('composer');

If you use this repository with the Twig extension, you can simultaneously load
resources from packages and your database now:

.. code-block:: jinja

    {% include 'cms:///ads/sidebar.html.twig' %}

    {% include '/acme/blog/views/footer.html.twig' %}

Further Reading
---------------

Read :doc:`getting-started` to learn how to install Puli in your project.

.. _Puli: https://github.com/puli/puli
.. _Composer: https://getcomposer.org
.. _PSR-4: http://www.php-fig.org/psr/psr-4/
.. _Composer plugin: https://github.com/puli/composer-puli-plugin
.. _Twig extension: https://github.com/puli/twig-puli-extension
.. _Symfony bridge: https://github.com/puli/symfony-puli-bridge
.. _stream wrapper: http://php.net/manual/en/intro.stream.php
